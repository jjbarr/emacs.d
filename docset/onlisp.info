This is onlisp.info, produced by makeinfo version 6.6 from onlisp.texi.

INFO-DIR-SECTION Common LISP
START-INFO-DIR-ENTRY
* On Lisp: (onlisp).                *On Lisp* by Paul Graham.
END-INFO-DIR-ENTRY


Indirect:
onlisp.info-1: 205
onlisp.info-2: 302573
onlisp.info-3: 600408

Tag Table:
(Indirect)
Node: Top205
Node: UTF1184
Node: Dedication page iii3991
Node: Dedication page iv4230
Node: Preface to this edition4465
Node: 1 Extensible Language19951
Node: 1-1 Design by Evolution21742
Node: 1-2 Programming Bottom-Up25984
Ref: 1-2 Programming Bottom-Up-Footnote-131608
Node: 1-3 Extensible Software31763
Node: 1-4 Extending Lisp35494
Ref: 1-4 Extending Lisp-Footnote-139405
Node: 1-5.Why Lisp (or When)39584
Node: 2 Functions42132
Node: 2-1 Functions as Data43775
Node: 2-2 Defining Functions45177
Node: 2-3 Functional Arguments50339
Node: 2-4 Functions as Properties54782
Node: 2-5 Scope57222
Node: 2-6 Closures59913
Ref: 2-6 Closures-Footnote-165654
Node: 2-7 Local Functions65784
Node: 2-8 Tail-Recursion69001
Ref: 2-8 Tail-Recursion-Footnote-172323
Node: 2-9 Compilation72418
Ref: 2-9 Compilation-Footnote-177390
Ref: 2-9 Compilation-Footnote-277475
Node: 2-10 Functions from Lists77714
Node: 3 Functional Programming78683
Node: 3-1 Functional Design79591
Ref: 3-1 Functional Design-Footnote-188703
Node: 3-2 Imperative Outside-In88755
Node: 3-3 Functional Interfaces93266
Ref: 3-3 Functional Interfaces-Footnote-199112
Node: 3-4 Interactive Programming99182
Node: 4 Utility Functions103427
Node: 4-1 Birth of a Utility104392
Node: 4-2 Invest in Abstraction110644
Node: 4-3 Operations on Lists114923
Node: 4-4 Search123749
Node: 4-5 Mapping131464
Node: 4-6 I/O136852
Node: 4-7 Symbols and Strings138415
Ref: 4-7 Symbols and Strings-Footnote-1141667
Node: 4-8 Density141748
Node: 5 Returning Functions144702
Node: 5-1 Common Lisp Evolves145828
Ref: 5-1 Common Lisp Evolves-Footnote-1149393
Ref: 5-1 Common Lisp Evolves-Footnote-2149472
Node: 5-2 Orthogonality149730
Node: 5-3 Memoizing153247
Node: 5-4 Composing Functions155268
Node: 5-5 Recursion on Cdrs158332
Ref: 5-5 Recursion on Cdrs-Footnote-1162731
Ref: 5-5 Recursion on Cdrs-Footnote-2162906
Node: 5-6 Recursion on Subtrees163020
Node: 5-7 When to Build Functions171275
Node: 6 Functions as Representation172748
Node: 6-1 Networks173902
Node: 6-2 Compiling Networks179031
Ref: 6-2 Compiling Networks-Footnote-1182811
Node: 6-3 Looking Forward182906
Node: 7 Macros183715
Node: 7-1 How Macros Work184620
Node: 7-2 Backquote189061
Ref: 7-2 Backquote-Footnote-1197207
Ref: 7-2 Backquote-Footnote-2197307
Node: 7-3 Defining Simple Macros197419
Node: 7-4 Testing Macroexpansion203191
Node: 7-5 Destructuring in Parameter Lists206710
Ref: 7-5 Destructuring in Parameter Lists-Footnote-1210484
Ref: 7-5 Destructuring in Parameter Lists-Footnote-2210795
Node: 7-6 A Model of Macros210908
Ref: 7-6 A Model of Macros-Footnote-1212921
Node: 7-7 Macros as Programs213011
Node: 7-8 Macro Style218560
Node: 7-9 Dependence on Macros225408
Ref: 7-9 Dependence on Macros-Footnote-1227766
Node: 7-10 Macros from Functions227870
Node: 7-11 Symbol Macros232528
Node: 8 When to Use Macros233609
Node: 8-1 When Nothing Else Will Do234905
Node: 8-2 Macro or Function?241215
Node: 8-3 Applications for Macros248061
Ref: 8-3 Applications for Macros-Footnote-1260578
Ref: 8-3 Applications for Macros-Footnote-2260737
Ref: 8-3 Applications for Macros-Footnote-3260824
Node: 9 Variable Capture260950
Node: 9-1 Macro Argument Capture261870
Node: 9-2 Free Symbol Capture264190
Node: 9-3 When Capture Occurs266503
Node: 9-4 Avoiding Capture with Better Names273818
Node: 9-5 Avoiding Capture by Prior Evaluation275113
Ref: 9-5 Avoiding Capture by Prior Evaluation-Footnote-1279783
Node: 9-6 Avoiding Capture with Gensyms279970
Node: 9-7 Avoiding Capture with Packages284093
Node: 9-8 Capture in Other Name-Spaces285290
Node: 9-9 Why Bother?288458
Node: 10 Other Macro Pitfalls290072
Node: 10-1 Number of Evaluations290740
Node: 10-2 Order of Evaluation293661
Node: 10-3 Non-functional Expanders295761
Ref: 10-3 Non-functional Expanders-Footnote-1302317
Node: 10-4 Recursion302573
Node: 11 Classic Macros309208
Node: 11-1 Creating Context310463
Node: 11-2 The with- Macro317102
Node: 11-3 Conditional Evaluation323190
Node: 11-4 Iteration330073
Node: 11-5 Iteration with Multiple Values336828
Node: 11-6 Need for Macros343661
Ref: 11-6 Need for Macros-Footnote-1348196
Node: 12 Generalized Variables348470
Node: 12-1 The Concept349460
Ref: 12-1 The Concept-Footnote-1353360
Node: 12-2 The Multiple Evaluation Problem353439
Ref: 12-2 The Multiple Evaluation Problem-Footnote-1356675
Node: 12-3 New Utilities356756
Node: 12-4 More Complex Utilities359985
Ref: 12-4 More Complex Utilities-Footnote-1372771
Ref: 12-4 More Complex Utilities-Footnote-2372963
Node: 12-5 Defining Inversions373094
Node: 13 Computation at Compile-Time377130
Node: 13-1 New Utilities377931
Node: 13-2 Example Bezier Curves385527
Node: 13-3 Applications388859
Node: 14 Anaphoric Macros392100
Node: 14-1 Anaphoric Variants393224
Ref: 14-1 Anaphoric Variants-Footnote-1403277
Node: 14-2 Failure403565
Node: 14-3 Referential Transparency410136
Node: 15 Macros Returning Functions413521
Node: 15-1 Building Functions414115
Node: 15-2 Recursion on Cdrs418347
Node: 15-3 Recursion on Subtrees425429
Node: 15-4 Lazy Evaluation430392
Node: 16 Macro-Defining Macros432232
Node: 16-1 Abbreviations432936
Ref: 16-1 Abbreviations-Footnote-1437744
Node: 16-2 Properties437813
Node: Anaphoric Macros441147
Node: 17 Read-Macros451270
Node: 17-1 Macro Characters451822
Node: 17-2 Dispatching Macro Characters455759
Node: 17-3 Delimiters458336
Node: 17-4 When What Happens461779
Node: 18 Destructuring462661
Node: 18-1 Destructuring on Lists463265
Node: 18-2 Other Structures465233
Node: 18-3 Reference474051
Node: 18-4 Matching478039
Node: 19 A Query Compiler492716
Node: 19-1 The Database495396
Node: 19-2 Pattern-Matching Queries498660
Node: 19-3 A Query Interpreter501634
Node: 19-4 Restrictions on Binding506417
Node: 19-5 A Query Compiler509226
Node: 20 Continuations516575
Node: 20-1 Scheme Continuations517778
Node: 20-2 Continuation-Passing Macros530351
Ref: 20-2 Continuation-Passing Macros-Footnote-1541786
Node: 20-3 Code-Walkers and CPS Conversion541969
Node: 21 Multiple Processes545863
Node: 21-1 The Process Abstraction546640
Node: 21-2 Implementation551744
Node: 21-3 The Less-than-Rapid Prototype563788
Node: 22 Nondeterminism567732
Node: 22-1 The Concept569092
Node: 22-2 Search576620
Ref: 22-2 Search-Footnote-1580962
Node: 22-3 Scheme Implementation581140
Node: 22-4 Common Lisp Implementation584654
Ref: 22-4 Common Lisp Implementation-Footnote-1593117
Node: 22-5 Cuts593256
Node: 22-6 True Nondeterminism600408
Node: 23 Parsing with ATNs605134
Node: 23-1 Background605794
Node: 23-2 The Formalism607627
Node: 23-3 Nondeterminism611169
Node: 23-4 An ATN Compiler613490
Node: 23-5 A Sample ATN626027
Node: 24 Prolog635141
Node: 24-1 Concepts636656
Ref: 24-1 Concepts-Footnote-1640009
Node: 24-2 An Interpreter640125
Node: 24-3 Rules649625
Node: 24-4 The Need for Nondeterminism655818
Node: 24-5 New Implementation659309
Node: 24-6 Adding Prolog Features665869
Node: 24-7 Examples678135
Node: 24-8 The Senses of Compile681044
Node: 25 Object-Oriented Lisp683377
Node: 25-1 Plus ça Change684149
Node: 25-2 Objects in Plain Lisp687542
Ref: 25-2 Objects in Plain Lisp-Footnote-1711689
Ref: 25-2 Objects in Plain Lisp-Footnote-2711779
Node: 25-3 Classes and Instances711898
Node: 25-4 Methods717943
Ref: 25-4 Methods-Footnote-1728907
Ref: 25-4 Methods-Footnote-2729026
Node: 25-5 Auxiliary Methods and Combination729175
Node: 25-7 When to Object738707
Node: Appendix Packages741627
Ref: Appendix Packages-Footnote-1751489
Ref: Appendix Packages-Footnote-2751562
Node: Notes751743
Node: Book's Index777569
Node: Concept Index798029
Node: Function Index817321

End Tag Table
